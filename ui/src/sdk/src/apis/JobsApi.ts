/* tslint:disable */
/* eslint-disable */
/**
 * AutoGlue API
 * API for managing K3s clusters across cloud providers
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  JobsEnqueueReq,
  JobsEnqueueResp,
  JobsJobListItem,
  JobsKPI,
  JobsQueueRollup,
} from '../models/index';
import {
    JobsEnqueueReqFromJSON,
    JobsEnqueueReqToJSON,
    JobsEnqueueRespFromJSON,
    JobsEnqueueRespToJSON,
    JobsJobListItemFromJSON,
    JobsJobListItemToJSON,
    JobsKPIFromJSON,
    JobsKPIToJSON,
    JobsQueueRollupFromJSON,
    JobsQueueRollupToJSON,
} from '../models/index';

export interface JobsCancelRequest {
    id: string;
}

export interface JobsEnqueueRequest {
    payload: JobsEnqueueReq;
}

export interface JobsGetActiveRequest {
    limit?: number;
}

export interface JobsGetFailuresRequest {
    limit?: number;
}

export interface JobsRetryNowRequest {
    id: string;
}

/**
 * 
 */
export class JobsApi extends runtime.BaseAPI {

    /**
     * Cancels running or scheduled jobs
     * Cancel a job
     */
    async jobsCancelRaw(requestParameters: JobsCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling jobsCancel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/api/v1/jobs/{id}/cancel`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Cancels running or scheduled jobs
     * Cancel a job
     */
    async jobsCancel(requestParameters: JobsCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.jobsCancelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Schedules a job on a queue with optional args/schedule
     * Manually enqueue a job
     */
    async jobsEnqueueRaw(requestParameters: JobsEnqueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JobsEnqueueResp>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling jobsEnqueue().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/api/v1/jobs/enqueue`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: JobsEnqueueReqToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JobsEnqueueRespFromJSON(jsonValue));
    }

    /**
     * Schedules a job on a queue with optional args/schedule
     * Manually enqueue a job
     */
    async jobsEnqueue(requestParameters: JobsEnqueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JobsEnqueueResp> {
        const response = await this.jobsEnqueueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Currently running jobs (limit default 100)
     * Active jobs
     */
    async jobsGetActiveRaw(requestParameters: JobsGetActiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<JobsJobListItem>>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/api/v1/jobs/active`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(JobsJobListItemFromJSON));
    }

    /**
     * Currently running jobs (limit default 100)
     * Active jobs
     */
    async jobsGetActive(requestParameters: JobsGetActiveRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<JobsJobListItem>> {
        const response = await this.jobsGetActiveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Failed jobs ordered by most recent (limit default 100)
     * Recent failures
     */
    async jobsGetFailuresRaw(requestParameters: JobsGetFailuresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<JobsJobListItem>>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/api/v1/jobs/failures`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(JobsJobListItemFromJSON));
    }

    /**
     * Failed jobs ordered by most recent (limit default 100)
     * Recent failures
     */
    async jobsGetFailures(requestParameters: JobsGetFailuresRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<JobsJobListItem>> {
        const response = await this.jobsGetFailuresRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Aggregated counters across all queues
     * Jobs KPI
     */
    async jobsGetKPIRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JobsKPI>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/api/v1/jobs/kpi`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JobsKPIFromJSON(jsonValue));
    }

    /**
     * Aggregated counters across all queues
     * Jobs KPI
     */
    async jobsGetKPI(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JobsKPI> {
        const response = await this.jobsGetKPIRaw(initOverrides);
        return await response.value();
    }

    /**
     * Counts and avg duration per queue (last 24h)
     * Per-queue rollups
     */
    async jobsGetQueuesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<JobsQueueRollup>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/api/v1/jobs/queues`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(JobsQueueRollupFromJSON));
    }

    /**
     * Counts and avg duration per queue (last 24h)
     * Per-queue rollups
     */
    async jobsGetQueues(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<JobsQueueRollup>> {
        const response = await this.jobsGetQueuesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Calls Archer ScheduleNow on the job id
     * Retry a job immediately
     */
    async jobsRetryNowRaw(requestParameters: JobsRetryNowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling jobsRetryNow().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // BearerAuth authentication
        }


        let urlPath = `/api/v1/jobs/{id}/retry`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Calls Archer ScheduleNow on the job id
     * Retry a job immediately
     */
    async jobsRetryNow(requestParameters: JobsRetryNowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.jobsRetryNowRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
