/* tslint:disable */
/* eslint-disable */
/**
 * AutoGlue API
 * API for managing K3s clusters across cloud providers
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  AnnotationsAddAnnotationToNodePool,
  AnnotationsAnnotationResponse,
  AnnotationsCreateAnnotationRequest,
  AnnotationsNodePoolBrief,
  AnnotationsUpdateAnnotationRequest,
} from "../models/index";
import {
  AnnotationsAddAnnotationToNodePoolFromJSON,
  AnnotationsAddAnnotationToNodePoolToJSON,
  AnnotationsAnnotationResponseFromJSON,
  AnnotationsAnnotationResponseToJSON,
  AnnotationsCreateAnnotationRequestFromJSON,
  AnnotationsCreateAnnotationRequestToJSON,
  AnnotationsNodePoolBriefFromJSON,
  AnnotationsNodePoolBriefToJSON,
  AnnotationsUpdateAnnotationRequestFromJSON,
  AnnotationsUpdateAnnotationRequestToJSON,
} from "../models/index";

export interface AddAnnotationToNodePoolsRequest {
  xOrgID: string;
  id: string;
  body: AnnotationsAddAnnotationToNodePool;
  include?: string;
}

export interface CreateAnnotationRequest {
  xOrgID: string;
  body: AnnotationsCreateAnnotationRequest;
}

export interface DeleteAnnotationRequest {
  xOrgID: string;
  id: string;
}

export interface GetAnnotationRequest {
  xOrgID: string;
  id: string;
  include?: string;
}

export interface ListAnnotationsRequest {
  xOrgID: string;
  name?: string;
  value?: string;
  q?: string;
  include?: string;
}

export interface ListNodePoolsWithAnnotationRequest {
  xOrgID: string;
  id: string;
  q?: string;
}

export interface RemoveAnnotationFromNodePoolRequest {
  xOrgID: string;
  id: string;
  poolId: string;
}

export interface UpdateAnnotationRequest {
  xOrgID: string;
  id: string;
  body: AnnotationsUpdateAnnotationRequest;
}

/**
 *
 */
export class AnnotationsApi extends runtime.BaseAPI {
  /**
   * Links the annotation to one or more node pools in the same organization.
   * Attach annotation to node pools (org scoped)
   */
  async addAnnotationToNodePoolsRaw(
    requestParameters: AddAnnotationToNodePoolsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AnnotationsAnnotationResponse>> {
    if (requestParameters["xOrgID"] == null) {
      throw new runtime.RequiredError(
        "xOrgID",
        'Required parameter "xOrgID" was null or undefined when calling addAnnotationToNodePools().',
      );
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling addAnnotationToNodePools().',
      );
    }

    if (requestParameters["body"] == null) {
      throw new runtime.RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addAnnotationToNodePools().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["include"] != null) {
      queryParameters["include"] = requestParameters["include"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/api/v1/annotations/{id}/node_pools`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AnnotationsAddAnnotationToNodePoolToJSON(
          requestParameters["body"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AnnotationsAnnotationResponseFromJSON(jsonValue),
    );
  }

  /**
   * Links the annotation to one or more node pools in the same organization.
   * Attach annotation to node pools (org scoped)
   */
  async addAnnotationToNodePools(
    requestParameters: AddAnnotationToNodePoolsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AnnotationsAnnotationResponse> {
    const response = await this.addAnnotationToNodePoolsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Creates an annotation. Optionally link to node pools.
   * Create annotation (org scoped)
   */
  async createAnnotationRaw(
    requestParameters: CreateAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AnnotationsAnnotationResponse>> {
    if (requestParameters["xOrgID"] == null) {
      throw new runtime.RequiredError(
        "xOrgID",
        'Required parameter "xOrgID" was null or undefined when calling createAnnotation().',
      );
    }

    if (requestParameters["body"] == null) {
      throw new runtime.RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createAnnotation().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/api/v1/annotations`;

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AnnotationsCreateAnnotationRequestToJSON(
          requestParameters["body"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AnnotationsAnnotationResponseFromJSON(jsonValue),
    );
  }

  /**
   * Creates an annotation. Optionally link to node pools.
   * Create annotation (org scoped)
   */
  async createAnnotation(
    requestParameters: CreateAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AnnotationsAnnotationResponse> {
    const response = await this.createAnnotationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Permanently deletes the annotation.
   * Delete annotation (org scoped)
   */
  async deleteAnnotationRaw(
    requestParameters: DeleteAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["xOrgID"] == null) {
      throw new runtime.RequiredError(
        "xOrgID",
        'Required parameter "xOrgID" was null or undefined when calling deleteAnnotation().',
      );
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling deleteAnnotation().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/api/v1/annotations/{id}`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Permanently deletes the annotation.
   * Delete annotation (org scoped)
   */
  async deleteAnnotation(
    requestParameters: DeleteAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.deleteAnnotationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns one annotation. Add `include=node_pools` to include node pools.
   * Get annotation by ID (org scoped)
   */
  async getAnnotationRaw(
    requestParameters: GetAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AnnotationsAnnotationResponse>> {
    if (requestParameters["xOrgID"] == null) {
      throw new runtime.RequiredError(
        "xOrgID",
        'Required parameter "xOrgID" was null or undefined when calling getAnnotation().',
      );
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getAnnotation().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["include"] != null) {
      queryParameters["include"] = requestParameters["include"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/api/v1/annotations/{id}`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AnnotationsAnnotationResponseFromJSON(jsonValue),
    );
  }

  /**
   * Returns one annotation. Add `include=node_pools` to include node pools.
   * Get annotation by ID (org scoped)
   */
  async getAnnotation(
    requestParameters: GetAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AnnotationsAnnotationResponse> {
    const response = await this.getAnnotationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns annotations for the organization in X-Org-ID. Filters: `name`, `value`, and `q` (name contains). Add `include=node_pools` to include linked node pools.
   * List annotations (org scoped)
   */
  async listAnnotationsRaw(
    requestParameters: ListAnnotationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<AnnotationsAnnotationResponse>>> {
    if (requestParameters["xOrgID"] == null) {
      throw new runtime.RequiredError(
        "xOrgID",
        'Required parameter "xOrgID" was null or undefined when calling listAnnotations().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["name"] != null) {
      queryParameters["name"] = requestParameters["name"];
    }

    if (requestParameters["value"] != null) {
      queryParameters["value"] = requestParameters["value"];
    }

    if (requestParameters["q"] != null) {
      queryParameters["q"] = requestParameters["q"];
    }

    if (requestParameters["include"] != null) {
      queryParameters["include"] = requestParameters["include"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/api/v1/annotations`;

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(AnnotationsAnnotationResponseFromJSON),
    );
  }

  /**
   * Returns annotations for the organization in X-Org-ID. Filters: `name`, `value`, and `q` (name contains). Add `include=node_pools` to include linked node pools.
   * List annotations (org scoped)
   */
  async listAnnotations(
    requestParameters: ListAnnotationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<AnnotationsAnnotationResponse>> {
    const response = await this.listAnnotationsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns node pools attached to the annotation. Supports `q` (name contains, case-insensitive).
   * List node pools linked to an annotation (org scoped)
   */
  async listNodePoolsWithAnnotationRaw(
    requestParameters: ListNodePoolsWithAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<AnnotationsNodePoolBrief>>> {
    if (requestParameters["xOrgID"] == null) {
      throw new runtime.RequiredError(
        "xOrgID",
        'Required parameter "xOrgID" was null or undefined when calling listNodePoolsWithAnnotation().',
      );
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling listNodePoolsWithAnnotation().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["q"] != null) {
      queryParameters["q"] = requestParameters["q"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/api/v1/annotations/{id}/node_pools`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(AnnotationsNodePoolBriefFromJSON),
    );
  }

  /**
   * Returns node pools attached to the annotation. Supports `q` (name contains, case-insensitive).
   * List node pools linked to an annotation (org scoped)
   */
  async listNodePoolsWithAnnotation(
    requestParameters: ListNodePoolsWithAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<AnnotationsNodePoolBrief>> {
    const response = await this.listNodePoolsWithAnnotationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Unlinks the annotation from the specified node pool.
   * Detach annotation from a node pool (org scoped)
   */
  async removeAnnotationFromNodePoolRaw(
    requestParameters: RemoveAnnotationFromNodePoolRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["xOrgID"] == null) {
      throw new runtime.RequiredError(
        "xOrgID",
        'Required parameter "xOrgID" was null or undefined when calling removeAnnotationFromNodePool().',
      );
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling removeAnnotationFromNodePool().',
      );
    }

    if (requestParameters["poolId"] == null) {
      throw new runtime.RequiredError(
        "poolId",
        'Required parameter "poolId" was null or undefined when calling removeAnnotationFromNodePool().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/api/v1/annotations/{id}/node_pools/{poolId}`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );
    urlPath = urlPath.replace(
      `{${"poolId"}}`,
      encodeURIComponent(String(requestParameters["poolId"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Unlinks the annotation from the specified node pool.
   * Detach annotation from a node pool (org scoped)
   */
  async removeAnnotationFromNodePool(
    requestParameters: RemoveAnnotationFromNodePoolRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.removeAnnotationFromNodePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Partially update annotation fields.
   * Update annotation (org scoped)
   */
  async updateAnnotationRaw(
    requestParameters: UpdateAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AnnotationsAnnotationResponse>> {
    if (requestParameters["xOrgID"] == null) {
      throw new runtime.RequiredError(
        "xOrgID",
        'Required parameter "xOrgID" was null or undefined when calling updateAnnotation().',
      );
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling updateAnnotation().',
      );
    }

    if (requestParameters["body"] == null) {
      throw new runtime.RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateAnnotation().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/api/v1/annotations/{id}`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: AnnotationsUpdateAnnotationRequestToJSON(
          requestParameters["body"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AnnotationsAnnotationResponseFromJSON(jsonValue),
    );
  }

  /**
   * Partially update annotation fields.
   * Update annotation (org scoped)
   */
  async updateAnnotation(
    requestParameters: UpdateAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AnnotationsAnnotationResponse> {
    const response = await this.updateAnnotationRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
