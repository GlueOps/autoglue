/* tslint:disable */
/* eslint-disable */
/**
 * AutoGlue API
 * API for managing K3s clusters across cloud providers
 *
 * The version of the OpenAPI document: dev
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  DtoAttachBastionRequest,
  DtoAttachCaptainDomainRequest,
  DtoAttachLoadBalancerRequest,
  DtoAttachNodePoolRequest,
  DtoAttachRecordSetRequest,
  DtoClusterResponse,
  DtoCreateClusterRequest,
  DtoSetKubeconfigRequest,
  DtoUpdateClusterRequest,
} from "../models/index";
import {
  DtoAttachBastionRequestFromJSON,
  DtoAttachBastionRequestToJSON,
  DtoAttachCaptainDomainRequestFromJSON,
  DtoAttachCaptainDomainRequestToJSON,
  DtoAttachLoadBalancerRequestFromJSON,
  DtoAttachLoadBalancerRequestToJSON,
  DtoAttachNodePoolRequestFromJSON,
  DtoAttachNodePoolRequestToJSON,
  DtoAttachRecordSetRequestFromJSON,
  DtoAttachRecordSetRequestToJSON,
  DtoClusterResponseFromJSON,
  DtoClusterResponseToJSON,
  DtoCreateClusterRequestFromJSON,
  DtoCreateClusterRequestToJSON,
  DtoSetKubeconfigRequestFromJSON,
  DtoSetKubeconfigRequestToJSON,
  DtoUpdateClusterRequestFromJSON,
  DtoUpdateClusterRequestToJSON,
} from "../models/index";

export interface AttachAppsLoadBalancerRequest {
  clusterID: string;
  dtoAttachLoadBalancerRequest: DtoAttachLoadBalancerRequest;
  xOrgID?: string;
}

export interface AttachBastionServerRequest {
  clusterID: string;
  dtoAttachBastionRequest: DtoAttachBastionRequest;
  xOrgID?: string;
}

export interface AttachCaptainDomainRequest {
  clusterID: string;
  dtoAttachCaptainDomainRequest: DtoAttachCaptainDomainRequest;
  xOrgID?: string;
}

export interface AttachControlPlaneRecordSetRequest {
  clusterID: string;
  dtoAttachRecordSetRequest: DtoAttachRecordSetRequest;
  xOrgID?: string;
}

export interface AttachGlueOpsLoadBalancerRequest {
  clusterID: string;
  dtoAttachLoadBalancerRequest: DtoAttachLoadBalancerRequest;
  xOrgID?: string;
}

export interface AttachNodePoolRequest {
  clusterID: string;
  dtoAttachNodePoolRequest: DtoAttachNodePoolRequest;
  xOrgID?: string;
}

export interface ClearClusterKubeconfigRequest {
  clusterID: string;
  xOrgID?: string;
}

export interface CreateClusterRequest {
  dtoCreateClusterRequest: DtoCreateClusterRequest;
  xOrgID?: string;
}

export interface DeleteClusterRequest {
  clusterID: string;
  xOrgID?: string;
}

export interface DetachAppsLoadBalancerRequest {
  clusterID: string;
  xOrgID?: string;
}

export interface DetachBastionServerRequest {
  clusterID: string;
  xOrgID?: string;
}

export interface DetachCaptainDomainRequest {
  clusterID: string;
  xOrgID?: string;
}

export interface DetachControlPlaneRecordSetRequest {
  clusterID: string;
  xOrgID?: string;
}

export interface DetachGlueOpsLoadBalancerRequest {
  clusterID: string;
  xOrgID?: string;
}

export interface DetachNodePoolRequest {
  clusterID: string;
  nodePoolID: string;
  xOrgID?: string;
}

export interface GetClusterRequest {
  clusterID: string;
  xOrgID?: string;
}

export interface ListClustersRequest {
  xOrgID?: string;
  q?: string;
}

export interface SetClusterKubeconfigRequest {
  clusterID: string;
  dtoSetKubeconfigRequest: DtoSetKubeconfigRequest;
  xOrgID?: string;
}

export interface UpdateClusterRequest {
  clusterID: string;
  dtoUpdateClusterRequest: DtoUpdateClusterRequest;
  xOrgID?: string;
}

/**
 *
 */
export class ClustersApi extends runtime.BaseAPI {
  /**
   * Sets apps_load_balancer_id on the cluster.
   * Attach an apps load balancer to a cluster
   */
  async attachAppsLoadBalancerRaw(
    requestParameters: AttachAppsLoadBalancerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling attachAppsLoadBalancer().',
      );
    }

    if (requestParameters["dtoAttachLoadBalancerRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoAttachLoadBalancerRequest",
        'Required parameter "dtoAttachLoadBalancerRequest" was null or undefined when calling attachAppsLoadBalancer().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/apps-load-balancer`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DtoAttachLoadBalancerRequestToJSON(
          requestParameters["dtoAttachLoadBalancerRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Sets apps_load_balancer_id on the cluster.
   * Attach an apps load balancer to a cluster
   */
  async attachAppsLoadBalancer(
    requestParameters: AttachAppsLoadBalancerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.attachAppsLoadBalancerRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Sets bastion_server_id on the cluster.
   * Attach a bastion server to a cluster
   */
  async attachBastionServerRaw(
    requestParameters: AttachBastionServerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling attachBastionServer().',
      );
    }

    if (requestParameters["dtoAttachBastionRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoAttachBastionRequest",
        'Required parameter "dtoAttachBastionRequest" was null or undefined when calling attachBastionServer().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/bastion`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DtoAttachBastionRequestToJSON(
          requestParameters["dtoAttachBastionRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Sets bastion_server_id on the cluster.
   * Attach a bastion server to a cluster
   */
  async attachBastionServer(
    requestParameters: AttachBastionServerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.attachBastionServerRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Sets captain_domain_id on the cluster. Validation of shape happens asynchronously.
   * Attach a captain domain to a cluster
   */
  async attachCaptainDomainRaw(
    requestParameters: AttachCaptainDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling attachCaptainDomain().',
      );
    }

    if (requestParameters["dtoAttachCaptainDomainRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoAttachCaptainDomainRequest",
        'Required parameter "dtoAttachCaptainDomainRequest" was null or undefined when calling attachCaptainDomain().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/captain-domain`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DtoAttachCaptainDomainRequestToJSON(
          requestParameters["dtoAttachCaptainDomainRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Sets captain_domain_id on the cluster. Validation of shape happens asynchronously.
   * Attach a captain domain to a cluster
   */
  async attachCaptainDomain(
    requestParameters: AttachCaptainDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.attachCaptainDomainRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Sets control_plane_record_set_id on the cluster.
   * Attach a control plane record set to a cluster
   */
  async attachControlPlaneRecordSetRaw(
    requestParameters: AttachControlPlaneRecordSetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling attachControlPlaneRecordSet().',
      );
    }

    if (requestParameters["dtoAttachRecordSetRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoAttachRecordSetRequest",
        'Required parameter "dtoAttachRecordSetRequest" was null or undefined when calling attachControlPlaneRecordSet().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/control-plane-record-set`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DtoAttachRecordSetRequestToJSON(
          requestParameters["dtoAttachRecordSetRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Sets control_plane_record_set_id on the cluster.
   * Attach a control plane record set to a cluster
   */
  async attachControlPlaneRecordSet(
    requestParameters: AttachControlPlaneRecordSetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.attachControlPlaneRecordSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Sets glueops_load_balancer_id on the cluster.
   * Attach a GlueOps/control-plane load balancer to a cluster
   */
  async attachGlueOpsLoadBalancerRaw(
    requestParameters: AttachGlueOpsLoadBalancerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling attachGlueOpsLoadBalancer().',
      );
    }

    if (requestParameters["dtoAttachLoadBalancerRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoAttachLoadBalancerRequest",
        'Required parameter "dtoAttachLoadBalancerRequest" was null or undefined when calling attachGlueOpsLoadBalancer().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/glueops-load-balancer`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DtoAttachLoadBalancerRequestToJSON(
          requestParameters["dtoAttachLoadBalancerRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Sets glueops_load_balancer_id on the cluster.
   * Attach a GlueOps/control-plane load balancer to a cluster
   */
  async attachGlueOpsLoadBalancer(
    requestParameters: AttachGlueOpsLoadBalancerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.attachGlueOpsLoadBalancerRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Adds an entry in the cluster_node_pools join table.
   * Attach a node pool to a cluster
   */
  async attachNodePoolRaw(
    requestParameters: AttachNodePoolRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling attachNodePool().',
      );
    }

    if (requestParameters["dtoAttachNodePoolRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoAttachNodePoolRequest",
        'Required parameter "dtoAttachNodePoolRequest" was null or undefined when calling attachNodePool().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/node-pools`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DtoAttachNodePoolRequestToJSON(
          requestParameters["dtoAttachNodePoolRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Adds an entry in the cluster_node_pools join table.
   * Attach a node pool to a cluster
   */
  async attachNodePool(
    requestParameters: AttachNodePoolRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.attachNodePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Removes the encrypted kubeconfig, IV, and tag from the cluster record.
   * Clear the kubeconfig for a cluster
   */
  async clearClusterKubeconfigRaw(
    requestParameters: ClearClusterKubeconfigRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling clearClusterKubeconfig().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/kubeconfig`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Removes the encrypted kubeconfig, IV, and tag from the cluster record.
   * Clear the kubeconfig for a cluster
   */
  async clearClusterKubeconfig(
    requestParameters: ClearClusterKubeconfigRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.clearClusterKubeconfigRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Creates a cluster. Status is managed by the system and starts as `pre_pending` for validation.
   * Create cluster (org scoped)
   */
  async createClusterRaw(
    requestParameters: CreateClusterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["dtoCreateClusterRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoCreateClusterRequest",
        'Required parameter "dtoCreateClusterRequest" was null or undefined when calling createCluster().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters`;

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DtoCreateClusterRequestToJSON(
          requestParameters["dtoCreateClusterRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Creates a cluster. Status is managed by the system and starts as `pre_pending` for validation.
   * Create cluster (org scoped)
   */
  async createCluster(
    requestParameters: CreateClusterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.createClusterRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Deletes the cluster. Related resources are cleaned up via DB constraints (e.g. CASCADE).
   * Delete a cluster (org scoped)
   */
  async deleteClusterRaw(
    requestParameters: DeleteClusterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling deleteCluster().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Deletes the cluster. Related resources are cleaned up via DB constraints (e.g. CASCADE).
   * Delete a cluster (org scoped)
   */
  async deleteCluster(
    requestParameters: DeleteClusterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.deleteClusterRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Clears apps_load_balancer_id on the cluster.
   * Detach the apps load balancer from a cluster
   */
  async detachAppsLoadBalancerRaw(
    requestParameters: DetachAppsLoadBalancerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling detachAppsLoadBalancer().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/apps-load-balancer`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Clears apps_load_balancer_id on the cluster.
   * Detach the apps load balancer from a cluster
   */
  async detachAppsLoadBalancer(
    requestParameters: DetachAppsLoadBalancerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.detachAppsLoadBalancerRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Clears bastion_server_id on the cluster.
   * Detach the bastion server from a cluster
   */
  async detachBastionServerRaw(
    requestParameters: DetachBastionServerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling detachBastionServer().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/bastion`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Clears bastion_server_id on the cluster.
   * Detach the bastion server from a cluster
   */
  async detachBastionServer(
    requestParameters: DetachBastionServerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.detachBastionServerRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Clears captain_domain_id on the cluster. This will likely cause the cluster to become incomplete.
   * Detach the captain domain from a cluster
   */
  async detachCaptainDomainRaw(
    requestParameters: DetachCaptainDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling detachCaptainDomain().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/captain-domain`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Clears captain_domain_id on the cluster. This will likely cause the cluster to become incomplete.
   * Detach the captain domain from a cluster
   */
  async detachCaptainDomain(
    requestParameters: DetachCaptainDomainRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.detachCaptainDomainRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Clears control_plane_record_set_id on the cluster.
   * Detach the control plane record set from a cluster
   */
  async detachControlPlaneRecordSetRaw(
    requestParameters: DetachControlPlaneRecordSetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling detachControlPlaneRecordSet().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/control-plane-record-set`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Clears control_plane_record_set_id on the cluster.
   * Detach the control plane record set from a cluster
   */
  async detachControlPlaneRecordSet(
    requestParameters: DetachControlPlaneRecordSetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.detachControlPlaneRecordSetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Clears glueops_load_balancer_id on the cluster.
   * Detach the GlueOps/control-plane load balancer from a cluster
   */
  async detachGlueOpsLoadBalancerRaw(
    requestParameters: DetachGlueOpsLoadBalancerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling detachGlueOpsLoadBalancer().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/glueops-load-balancer`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Clears glueops_load_balancer_id on the cluster.
   * Detach the GlueOps/control-plane load balancer from a cluster
   */
  async detachGlueOpsLoadBalancer(
    requestParameters: DetachGlueOpsLoadBalancerRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.detachGlueOpsLoadBalancerRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Removes an entry from the cluster_node_pools join table.
   * Detach a node pool from a cluster
   */
  async detachNodePoolRaw(
    requestParameters: DetachNodePoolRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling detachNodePool().',
      );
    }

    if (requestParameters["nodePoolID"] == null) {
      throw new runtime.RequiredError(
        "nodePoolID",
        'Required parameter "nodePoolID" was null or undefined when calling detachNodePool().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/node-pools/{nodePoolID}`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );
    urlPath = urlPath.replace(
      `{${"nodePoolID"}}`,
      encodeURIComponent(String(requestParameters["nodePoolID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Removes an entry from the cluster_node_pools join table.
   * Detach a node pool from a cluster
   */
  async detachNodePool(
    requestParameters: DetachNodePoolRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.detachNodePoolRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns a cluster with all related resources (domain, record set, load balancers, bastion, node pools).
   * Get a single cluster by ID (org scoped)
   */
  async getClusterRaw(
    requestParameters: GetClusterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling getCluster().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Returns a cluster with all related resources (domain, record set, load balancers, bastion, node pools).
   * Get a single cluster by ID (org scoped)
   */
  async getCluster(
    requestParameters: GetClusterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.getClusterRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Returns clusters for the organization in X-Org-ID. Filter by `q` (name contains).
   * List clusters (org scoped)
   */
  async listClustersRaw(
    requestParameters: ListClustersRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<DtoClusterResponse>>> {
    const queryParameters: any = {};

    if (requestParameters["q"] != null) {
      queryParameters["q"] = requestParameters["q"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters`;

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(DtoClusterResponseFromJSON),
    );
  }

  /**
   * Returns clusters for the organization in X-Org-ID. Filter by `q` (name contains).
   * List clusters (org scoped)
   */
  async listClusters(
    requestParameters: ListClustersRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<DtoClusterResponse>> {
    const response = await this.listClustersRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Stores the kubeconfig encrypted per organization. The kubeconfig is never returned in responses.
   * Set (or replace) the kubeconfig for a cluster
   */
  async setClusterKubeconfigRaw(
    requestParameters: SetClusterKubeconfigRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling setClusterKubeconfig().',
      );
    }

    if (requestParameters["dtoSetKubeconfigRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoSetKubeconfigRequest",
        'Required parameter "dtoSetKubeconfigRequest" was null or undefined when calling setClusterKubeconfig().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}/kubeconfig`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DtoSetKubeconfigRequestToJSON(
          requestParameters["dtoSetKubeconfigRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Stores the kubeconfig encrypted per organization. The kubeconfig is never returned in responses.
   * Set (or replace) the kubeconfig for a cluster
   */
  async setClusterKubeconfig(
    requestParameters: SetClusterKubeconfigRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.setClusterKubeconfigRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Updates the cluster name, provider, and/or region. Status is managed by the system.
   * Update basic cluster details (org scoped)
   */
  async updateClusterRaw(
    requestParameters: UpdateClusterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DtoClusterResponse>> {
    if (requestParameters["clusterID"] == null) {
      throw new runtime.RequiredError(
        "clusterID",
        'Required parameter "clusterID" was null or undefined when calling updateCluster().',
      );
    }

    if (requestParameters["dtoUpdateClusterRequest"] == null) {
      throw new runtime.RequiredError(
        "dtoUpdateClusterRequest",
        'Required parameter "dtoUpdateClusterRequest" was null or undefined when calling updateCluster().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (requestParameters["xOrgID"] != null) {
      headerParameters["X-Org-ID"] = String(requestParameters["xOrgID"]);
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-KEY"] =
        await this.configuration.apiKey("X-ORG-KEY"); // OrgKeyAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-ORG-SECRET"] =
        await this.configuration.apiKey("X-ORG-SECRET"); // OrgSecretAuth authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // BearerAuth authentication
    }

    let urlPath = `/clusters/{clusterID}`;
    urlPath = urlPath.replace(
      `{${"clusterID"}}`,
      encodeURIComponent(String(requestParameters["clusterID"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: DtoUpdateClusterRequestToJSON(
          requestParameters["dtoUpdateClusterRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DtoClusterResponseFromJSON(jsonValue),
    );
  }

  /**
   * Updates the cluster name, provider, and/or region. Status is managed by the system.
   * Update basic cluster details (org scoped)
   */
  async updateCluster(
    requestParameters: UpdateClusterRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DtoClusterResponse> {
    const response = await this.updateClusterRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
